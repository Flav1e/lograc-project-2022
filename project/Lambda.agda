
module Lambda where

--import

open import Data.Bool using (Bool; true; false; T; not)
open import Data.Empty using (âŠ¥; âŠ¥-elim)
open import Data.List using (List; _âˆ·_; [])
open import Data.Nat using (â„•; zero; suc)
open import Data.Product using (âˆƒ-syntax; _Ã—_)
open import Data.String using (String; _â‰Ÿ_)
open import Data.Unit using (tt)
open import Relation.Nullary using (Dec; yes; no; Â¬_)
open import Relation.Nullary.Decidable using (False; toWitnessFalse)
open import Relation.Nullary.Negation using (Â¬?)
open import Relation.Binary.PropositionalEquality using (_â‰¡_; _â‰¢_; refl)

--Syntax of terms

Id : Set
Id = String

infix  5  Æ›_â‡’_ --abstraction
infix  5  Î¼_â‡’_ --fixpoint
infixl 7  _Â·_ --application
infix  8  `suc_ --successor
infix  9  `_  --variables
infixl 10 inl_ -- left injection 
infixr 10 inr_ --right injection

data Term : Set where
  `_                      :  Id â†’ Term
  Æ›_â‡’_                    :  Id â†’ Term â†’ Term
  _Â·_                     :  Term â†’ Term â†’ Term
  `zero                   :  Term
  `suc_                   :  Term â†’ Term
  case_[zeroâ‡’_|suc_â‡’_]    :  Term â†’ Term â†’ Id â†’ Term â†’ Term
  Î¼_â‡’_                    :  Id â†’ Term â†’ Term
  inl_                     : Term â†’ Term 
  inr_                     : Term â†’ Term 
  case_[inl_â‡’_|inr_â‡’_] :  Term â†’ Term â†’ Id â†’ Term â†’ Term


 --Example terms

two : Term
two = `suc `suc `zero

plus : Term
plus = Î¼ "+" â‡’ Æ› "m" â‡’ Æ› "n" â‡’
         case ` "m"
           [zeroâ‡’ ` "n"
           |suc "m" â‡’ `suc (` "+" Â· ` "m" Â· ` "n") ] 

twoá¶œ : Term
twoá¶œ =  Æ› "s" â‡’ Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z")

plusá¶œ : Term
plusá¶œ =  Æ› "m" â‡’ Æ› "n" â‡’ Æ› "s" â‡’ Æ› "z" â‡’
         ` "m" Â· ` "s" Â· (` "n" Â· ` "s" Â· ` "z")

sucá¶œ : Term
sucá¶œ = Æ› "n" â‡’ `suc (` "n")

-- Your code goes here

-- Your code goes here

-- Exercise `primed` (stretch) {#primed}

var? : (t : Term) â†’ Bool
var? (` _)  =  true
var? _      =  false

Æ›â€²_â‡’_ : (t : Term) â†’ {_ : T (var? t)} â†’ Term â†’ Term
Æ›â€²_â‡’_ (` x) N = Æ› x â‡’ N

caseâ€²_[zeroâ‡’_|suc_â‡’_] : Term â†’ Term â†’ (t : Term) â†’ {_ : T (var? t)} â†’ Term â†’ Term
caseâ€² L [zeroâ‡’ M |suc (` x) â‡’ N ]  =  case L [zeroâ‡’ M |suc x â‡’ N ]

Î¼â€²_â‡’_ : (t : Term) â†’ {_ : T (var? t)} â†’ Term â†’ Term
Î¼â€² (` x) â‡’ N  =  Î¼ x â‡’ N

--definition of plus :
plusâ€² : Term
plusâ€² = Î¼â€² + â‡’ Æ›â€² m â‡’ Æ›â€² n â‡’
          caseâ€² m
            [zeroâ‡’ n
            |suc m â‡’ `suc (+ Â· m Â· n) ]
  where
  +  =  ` "+"
  m  =  ` "m"
  n  =  ` "n"

-- Values
data Value : Term â†’ Set where

  V-Æ› : âˆ€ {x N}
      ---------------
    â†’ Value (Æ› x â‡’ N)

  V-zero :
      -----------
      Value `zero

  V-suc : âˆ€ {V}
    â†’ Value V
      --------------
    â†’ Value (`suc V)

{-
-- add inl et inr

 -- V-inl : A
      ------------
      â†’ Value (?)

 -- V-inr : B 
      ------------
      â†’ Value (?)
-}


infix 9 _[_:=_]

_[_:=_] : Term â†’ Id â†’ Term â†’ Term
(` x) [ y := V ] with x â‰Ÿ y
... | yes _          =  V
... | no  _          =  ` x
(Æ› x â‡’ N) [ y := V ] with x â‰Ÿ y
... | yes _          =  Æ› x â‡’ N
... | no  _          =  Æ› x â‡’ N [ y := V ]
(L Â· M) [ y := V ]   =  L [ y := V ] Â· M [ y := V ]
(`zero) [ y := V ]   =  `zero
(`suc M) [ y := V ]  =  `suc M [ y := V ]
(case L [zeroâ‡’ M |suc x â‡’ N ]) [ y := V ] with x â‰Ÿ y
... | yes _          =  case L [ y := V ] [zeroâ‡’ M [ y := V ] |suc x â‡’ N ]
... | no  _          =  case L [ y := V ] [zeroâ‡’ M [ y := V ] |suc x â‡’ N [ y := V ] ]
(Î¼ x â‡’ N) [ y := V ] with x â‰Ÿ y
... | yes _          =  Î¼ x â‡’ N
... | no  _          =  Î¼ x â‡’ N [ y := V ]


{-
(case K [ xâ‚‚ inl â‡’ M|inr xâ‚‚ â‡’ N ]) [ x := xâ‚ ]
  xâ‚‚ inl [ x := xâ‚ ]
  inr xâ‚‚ [ x := xâ‚ ]
  case_[_inlâ‡’_|inr_â‡’_] xâ‚‚ xâ‚ƒ xâ‚„ xâ‚… [ x := xâ‚ ]


-- to be completed
(case K [l inl â‡’ M|inr r â‡’ N]) [ y := V ] with l â‰Ÿ y
... | yes _          = case K [ y := V ] [l inl â‡’ M [ y := V ] |inr r â‡’ N]
... | no _           = case K [ y := V ] [l inl â‡’ M [ y := V ] |inr r â‡’ N [ y := V ] ]
(case K [l inl â‡’ M|inr r â‡’ N]) [ y := V ] with r â‰Ÿ y
... | yes _          = case K [ y := V ] [l inl â‡’ M|inr r â‡’ N [ y := V ] ]
... | no _           = case K [ y := V ] [l inl â‡’ M [ y := V ]|inr r â‡’ N [ y := V ] ]                                              

-}

-- Examples
_ : (Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z")) [ "s" := sucá¶œ ] â‰¡ Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")
_ = refl

_ : (sucá¶œ Â· (sucá¶œ Â· ` "z")) [ "z" := `zero ] â‰¡ sucá¶œ Â· (sucá¶œ Â· `zero)
_ = refl

_ : (Æ› "x" â‡’ ` "y") [ "y" := `zero ] â‰¡ Æ› "x" â‡’ `zero
_ = refl

_ : (Æ› "x" â‡’ ` "x") [ "x" := `zero ] â‰¡ Æ› "x" â‡’ ` "x"
_ = refl

_ : (Æ› "y" â‡’ ` "y") [ "x" := `zero ] â‰¡ Æ› "y" â‡’ ` "y"
_ = refl

-- Your code goes here

{-
-- Reduction
infix 4 _â€”â†’_

data _â€”â†’_ : Term â†’ Term â†’ Set where

  Î¾-Â·â‚ : âˆ€ {L Lâ€² M}
    â†’ L â€”â†’ Lâ€²
      -----------------
    â†’ L Â· M â€”â†’ Lâ€² Â· M

  Î¾-Â·â‚‚ : âˆ€ {V M Mâ€²}
    â†’ Value V
    â†’ M â€”â†’ Mâ€²
      -----------------
    â†’ V Â· M â€”â†’ V Â· Mâ€²

  Î²-Æ› : âˆ€ {x N V}
    â†’ Value V
      ------------------------------
    â†’ (Æ› x â‡’ N) Â· V â€”â†’ N [ x := V ]

  Î¾-suc : âˆ€ {M Mâ€²}
    â†’ M â€”â†’ Mâ€²
      ------------------
    â†’ `suc M â€”â†’ `suc Mâ€²

  Î¾-case : âˆ€ {x L Lâ€² M N}
    â†’ L â€”â†’ Lâ€²
      -----------------------------------------------------------------
    â†’ case L [zeroâ‡’ M |suc x â‡’ N ] â€”â†’ case Lâ€² [zeroâ‡’ M |suc x â‡’ N ]

  Î²-zero : âˆ€ {x M N}
      ----------------------------------------
    â†’ case `zero [zeroâ‡’ M |suc x â‡’ N ] â€”â†’ M

  Î²-suc : âˆ€ {x V M N}
    â†’ Value V
      ---------------------------------------------------
    â†’ case `suc V [zeroâ‡’ M |suc x â‡’ N ] â€”â†’ N [ x := V ]

  Î²-Î¼ : âˆ€ {x M}
      ------------------------------
    â†’ Î¼ x â‡’ M â€”â†’ M [ x := Î¼ x â‡’ M ]

-- Reflexive and transitive closure

infix  2 _â€”â† _
infix  1 begin_
infixr 2 _â€”â†’âŸ¨_âŸ©_
infix  3 _âˆŽ

data _â€”â† _ : Term â†’ Term â†’ Set where
  _âˆŽ : âˆ€ M
      ---------
    â†’ M â€”â†  M

  _â€”â†’âŸ¨_âŸ©_ : âˆ€ L {M N}
    â†’ L â€”â†’ M
    â†’ M â€”â†  N
      ---------
    â†’ L â€”â†  N

begin_ : âˆ€ {M N}
  â†’ M â€”â†  N
    ------
  â†’ M â€”â†  N
begin Mâ€”â† N = Mâ€”â† N

data _â€”â† â€²_ : Term â†’ Term â†’ Set where

  stepâ€² : âˆ€ {M N}
    â†’ M â€”â†’ N
      -------
    â†’ M â€”â† â€² N

  reflâ€² : âˆ€ {M}
      -------
    â†’ M â€”â† â€² M

  transâ€² : âˆ€ {L M N}
    â†’ L â€”â† â€² M
    â†’ M â€”â† â€² N
      -------
    â†’ L â€”â† â€² N

-- Your code goes here

-- Confluence
postulate
  confluence : âˆ€ {L M N}
    â†’ ((L â€”â†  M) Ã— (L â€”â†  N))
      --------------------
    â†’ âˆƒ[ P ] ((M â€”â†  P) Ã— (N â€”â†  P))

  diamond : âˆ€ {L M N}
    â†’ ((L â€”â†’ M) Ã— (L â€”â†’ N))
      --------------------
    â†’ âˆƒ[ P ] ((M â€”â†  P) Ã— (N â€”â†  P))

postulate
  deterministic : âˆ€ {L M N}
    â†’ L â€”â†’ M
    â†’ L â€”â†’ N
      ------
    â†’ M â‰¡ N

-- Examples
_ : twoá¶œ Â· sucá¶œ Â· `zero â€”â†  `suc `suc `zero
_ =
  begin
    twoá¶œ Â· sucá¶œ Â· `zero
  â€”â†’âŸ¨ Î¾-Â·â‚ (Î²-Æ› V-Æ›) âŸ©
    (Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· `zero
  â€”â†’âŸ¨ Î²-Æ› V-zero âŸ©
    sucá¶œ Â· (sucá¶œ Â· `zero)
  â€”â†’âŸ¨ Î¾-Â·â‚‚ V-Æ› (Î²-Æ› V-zero) âŸ©
    sucá¶œ Â· `suc `zero
  â€”â†’âŸ¨ Î²-Æ› (V-suc V-zero) âŸ©
    `suc (`suc `zero)
  âˆŽ

_ : plus Â· two Â· two â€”â†  `suc `suc `suc `suc `zero
_ =
  begin
    plus Â· two Â· two
  â€”â†’âŸ¨ Î¾-Â·â‚ (Î¾-Â·â‚ Î²-Î¼) âŸ©
    (Æ› "m" â‡’ Æ› "n" â‡’
      case ` "m" [zeroâ‡’ ` "n" |suc "m" â‡’ `suc (plus Â· ` "m" Â· ` "n") ])
        Â· two Â· two
  â€”â†’âŸ¨ Î¾-Â·â‚ (Î²-Æ› (V-suc (V-suc V-zero))) âŸ©
    (Æ› "n" â‡’
      case two [zeroâ‡’ ` "n" |suc "m" â‡’ `suc (plus Â· ` "m" Â· ` "n") ])
         Â· two
  â€”â†’âŸ¨ Î²-Æ› (V-suc (V-suc V-zero)) âŸ©
    case two [zeroâ‡’ two |suc "m" â‡’ `suc (plus Â· ` "m" Â· two) ]
  â€”â†’âŸ¨ Î²-suc (V-suc V-zero) âŸ©
    `suc (plus Â· `suc `zero Â· two)
  â€”â†’âŸ¨ Î¾-suc (Î¾-Â·â‚ (Î¾-Â·â‚ Î²-Î¼)) âŸ©
    `suc ((Æ› "m" â‡’ Æ› "n" â‡’
      case ` "m" [zeroâ‡’ ` "n" |suc "m" â‡’ `suc (plus Â· ` "m" Â· ` "n") ])
        Â· `suc `zero Â· two)
  â€”â†’âŸ¨ Î¾-suc (Î¾-Â·â‚ (Î²-Æ› (V-suc V-zero))) âŸ©
    `suc ((Æ› "n" â‡’
      case `suc `zero [zeroâ‡’ ` "n" |suc "m" â‡’ `suc (plus Â· ` "m" Â· ` "n") ])
        Â· two)
  â€”â†’âŸ¨ Î¾-suc (Î²-Æ› (V-suc (V-suc V-zero))) âŸ©
    `suc (case `suc `zero [zeroâ‡’ two |suc "m" â‡’ `suc (plus Â· ` "m" Â· two) ])
  â€”â†’âŸ¨ Î¾-suc (Î²-suc V-zero) âŸ©
    `suc `suc (plus Â· `zero Â· two)
  â€”â†’âŸ¨ Î¾-suc (Î¾-suc (Î¾-Â·â‚ (Î¾-Â·â‚ Î²-Î¼))) âŸ©
    `suc `suc ((Æ› "m" â‡’ Æ› "n" â‡’
      case ` "m" [zeroâ‡’ ` "n" |suc "m" â‡’ `suc (plus Â· ` "m" Â· ` "n") ])
        Â· `zero Â· two)
  â€”â†’âŸ¨ Î¾-suc (Î¾-suc (Î¾-Â·â‚ (Î²-Æ› V-zero))) âŸ©
    `suc `suc ((Æ› "n" â‡’
      case `zero [zeroâ‡’ ` "n" |suc "m" â‡’ `suc (plus Â· ` "m" Â· ` "n") ])
        Â· two)
  â€”â†’âŸ¨ Î¾-suc (Î¾-suc (Î²-Æ› (V-suc (V-suc V-zero)))) âŸ©
    `suc `suc (case `zero [zeroâ‡’ two |suc "m" â‡’ `suc (plus Â· ` "m" Â· two) ])
  â€”â†’âŸ¨ Î¾-suc (Î¾-suc Î²-zero) âŸ©
    `suc (`suc (`suc (`suc `zero)))
  âˆŽ

_ : plusá¶œ Â· twoá¶œ Â· twoá¶œ Â· sucá¶œ Â· `zero â€”â†  `suc `suc `suc `suc `zero
_ =
  begin
    (Æ› "m" â‡’ Æ› "n" â‡’ Æ› "s" â‡’ Æ› "z" â‡’ ` "m" Â· ` "s" Â· (` "n" Â· ` "s" Â· ` "z"))
      Â· twoá¶œ Â· twoá¶œ Â· sucá¶œ Â· `zero
  â€”â†’âŸ¨ Î¾-Â·â‚ (Î¾-Â·â‚ (Î¾-Â·â‚ (Î²-Æ› V-Æ›))) âŸ©
    (Æ› "n" â‡’ Æ› "s" â‡’ Æ› "z" â‡’ twoá¶œ Â· ` "s" Â· (` "n" Â· ` "s" Â· ` "z"))
      Â· twoá¶œ Â· sucá¶œ Â· `zero
  â€”â†’âŸ¨ Î¾-Â·â‚ (Î¾-Â·â‚ (Î²-Æ› V-Æ›)) âŸ©
    (Æ› "s" â‡’ Æ› "z" â‡’ twoá¶œ Â· ` "s" Â· (twoá¶œ Â· ` "s" Â· ` "z")) Â· sucá¶œ Â· `zero
  â€”â†’âŸ¨ Î¾-Â·â‚ (Î²-Æ› V-Æ›) âŸ©
    (Æ› "z" â‡’ twoá¶œ Â· sucá¶œ Â· (twoá¶œ Â· sucá¶œ Â· ` "z")) Â· `zero
  â€”â†’âŸ¨ Î²-Æ› V-zero âŸ©
    twoá¶œ Â· sucá¶œ Â· (twoá¶œ Â· sucá¶œ Â· `zero)
  â€”â†’âŸ¨ Î¾-Â·â‚ (Î²-Æ› V-Æ›) âŸ©
    (Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· (twoá¶œ Â· sucá¶œ Â· `zero)
  â€”â†’âŸ¨ Î¾-Â·â‚‚ V-Æ› (Î¾-Â·â‚ (Î²-Æ› V-Æ›)) âŸ©
    (Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· ((Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· `zero)
  â€”â†’âŸ¨ Î¾-Â·â‚‚ V-Æ› (Î²-Æ› V-zero) âŸ©
    (Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· (sucá¶œ Â· (sucá¶œ Â· `zero))
  â€”â†’âŸ¨ Î¾-Â·â‚‚ V-Æ› (Î¾-Â·â‚‚ V-Æ› (Î²-Æ› V-zero)) âŸ©
    (Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· (sucá¶œ Â· (`suc `zero))
  â€”â†’âŸ¨ Î¾-Â·â‚‚ V-Æ› (Î²-Æ› (V-suc V-zero)) âŸ©
    (Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· (`suc `suc `zero)
  â€”â†’âŸ¨ Î²-Æ› (V-suc (V-suc V-zero)) âŸ©
    sucá¶œ Â· (sucá¶œ Â· `suc `suc `zero)
  â€”â†’âŸ¨ Î¾-Â·â‚‚ V-Æ› (Î²-Æ› (V-suc (V-suc V-zero))) âŸ©
    sucá¶œ Â· (`suc `suc `suc `zero)
  â€”â†’âŸ¨ Î²-Æ› (V-suc (V-suc (V-suc V-zero))) âŸ©
   `suc (`suc (`suc (`suc `zero)))
  âˆŽ


-- Your code goes here

-- Syntax of types

infixr 7 _â‡’_

data Type : Set where
  _â‡’_ : Type â†’ Type â†’ Type
  `â„• : Type

-- Precedence

 -- Typing
 -- Contexts

infixl 5  _,_â¦‚_

data Context : Set where
  âˆ…     : Context
  _,_â¦‚_ : Context â†’ Id â†’ Type â†’ Context

-- Your code goes here

-- Lookup judgment

infix  4  _âˆ‹_â¦‚_

data _âˆ‹_â¦‚_ : Context â†’ Id â†’ Type â†’ Set where

  Z : âˆ€ {Î“ x A}
      ------------------
    â†’ Î“ , x â¦‚ A âˆ‹ x â¦‚ A

  S : âˆ€ {Î“ x y A B}
    â†’ x â‰¢ y
    â†’ Î“ âˆ‹ x â¦‚ A
      ------------------
    â†’ Î“ , y â¦‚ B âˆ‹ x â¦‚ A

_ : âˆ… , "x" â¦‚ `â„• â‡’ `â„• , "y" â¦‚ `â„• , "z" â¦‚ `â„• âˆ‹ "x" â¦‚ `â„• â‡’ `â„•
_ = S (Î»()) (S (Î»()) Z)

Sâ€² : âˆ€ {Î“ x y A B}
   â†’ {xâ‰¢y : False (x â‰Ÿ y)}
   â†’ Î“ âˆ‹ x â¦‚ A
     ------------------
   â†’ Î“ , y â¦‚ B âˆ‹ x â¦‚ A

Sâ€² {xâ‰¢y = xâ‰¢y} x = S (toWitnessFalse xâ‰¢y) x

-- Typing judgment

infix  4  _âŠ¢_â¦‚_

data _âŠ¢_â¦‚_ : Context â†’ Term â†’ Type â†’ Set where

  -- Axiom
  âŠ¢` : âˆ€ {Î“ x A}
    â†’ Î“ âˆ‹ x â¦‚ A
      -----------
    â†’ Î“ âŠ¢ ` x â¦‚ A

  -- â‡’-I
  âŠ¢Æ› : âˆ€ {Î“ x N A B}
    â†’ Î“ , x â¦‚ A âŠ¢ N â¦‚ B
      -------------------
    â†’ Î“ âŠ¢ Æ› x â‡’ N â¦‚ A â‡’ B

  -- â‡’-E
  _Â·_ : âˆ€ {Î“ L M A B}
    â†’ Î“ âŠ¢ L â¦‚ A â‡’ B
    â†’ Î“ âŠ¢ M â¦‚ A
      -------------
    â†’ Î“ âŠ¢ L Â· M â¦‚ B

  -- â„•-Iâ‚
  âŠ¢zero : âˆ€ {Î“}
      --------------
    â†’ Î“ âŠ¢ `zero â¦‚ `â„•

  -- â„•-Iâ‚‚
  âŠ¢suc : âˆ€ {Î“ M}
    â†’ Î“ âŠ¢ M â¦‚ `â„•
      ---------------
    â†’ Î“ âŠ¢ `suc M â¦‚ `â„•

  -- â„•-E
  âŠ¢case : âˆ€ {Î“ L M x N A}
    â†’ Î“ âŠ¢ L â¦‚ `â„•
    â†’ Î“ âŠ¢ M â¦‚ A
    â†’ Î“ , x â¦‚ `â„• âŠ¢ N â¦‚ A
      -------------------------------------
    â†’ Î“ âŠ¢ case L [zeroâ‡’ M |suc x â‡’ N ] â¦‚ A

  âŠ¢Î¼ : âˆ€ {Î“ x M A}
    â†’ Î“ , x â¦‚ A âŠ¢ M â¦‚ A
      -----------------
    â†’ Î“ âŠ¢ Î¼ x â‡’ M â¦‚ A

-- Example type derivations {#derivation}

Ch : Type â†’ Type
Ch A = (A â‡’ A) â‡’ A â‡’ A

âŠ¢twoá¶œ : âˆ€ {Î“ A} â†’ Î“ âŠ¢ twoá¶œ â¦‚ Ch A
âŠ¢twoá¶œ = âŠ¢Æ› (âŠ¢Æ› (âŠ¢` âˆ‹s Â· (âŠ¢` âˆ‹s Â· âŠ¢` âˆ‹z)))
  where
  âˆ‹s = Sâ€² Z
  âˆ‹z = Z

âŠ¢two : âˆ€ {Î“} â†’ Î“ âŠ¢ two â¦‚ `â„•
âŠ¢two = âŠ¢suc (âŠ¢suc âŠ¢zero)

âŠ¢plus : âˆ€ {Î“} â†’ Î“ âŠ¢ plus â¦‚ `â„• â‡’ `â„• â‡’ `â„•
âŠ¢plus = âŠ¢Î¼ (âŠ¢Æ› (âŠ¢Æ› (âŠ¢case (âŠ¢` âˆ‹m) (âŠ¢` âˆ‹n)
         (âŠ¢suc (âŠ¢` âˆ‹+ Â· âŠ¢` âˆ‹mâ€² Â· âŠ¢` âˆ‹nâ€²)))))
  where
  âˆ‹+  = Sâ€² (Sâ€² (Sâ€² Z))
  âˆ‹m  = Sâ€² Z
  âˆ‹n  = Z
  âˆ‹mâ€² = Z
  âˆ‹nâ€² = Sâ€² Z

âŠ¢2+2 : âˆ… âŠ¢ plus Â· two Â· two â¦‚ `â„•
âŠ¢2+2 = âŠ¢plus Â· âŠ¢two Â· âŠ¢two

âŠ¢plusá¶œ : âˆ€ {Î“ A} â†’ Î“  âŠ¢ plusá¶œ â¦‚ Ch A â‡’ Ch A â‡’ Ch A
âŠ¢plusá¶œ = âŠ¢Æ› (âŠ¢Æ› (âŠ¢Æ› (âŠ¢Æ› (âŠ¢` âˆ‹m Â· âŠ¢` âˆ‹s Â· (âŠ¢` âˆ‹n Â· âŠ¢` âˆ‹s Â· âŠ¢` âˆ‹z)))))
  where
  âˆ‹m = Sâ€² (Sâ€² (Sâ€² Z))
  âˆ‹n = Sâ€² (Sâ€² Z)
  âˆ‹s = Sâ€² Z
  âˆ‹z = Z

âŠ¢sucá¶œ : âˆ€ {Î“} â†’ Î“ âŠ¢ sucá¶œ â¦‚ `â„• â‡’ `â„•
âŠ¢sucá¶œ = âŠ¢Æ› (âŠ¢suc (âŠ¢` âˆ‹n))
  where
  âˆ‹n = Z

âŠ¢2+2á¶œ : âˆ… âŠ¢ plusá¶œ Â· twoá¶œ Â· twoá¶œ Â· sucá¶œ Â· `zero â¦‚ `â„•
âŠ¢2+2á¶œ = âŠ¢plusá¶œ Â· âŠ¢twoá¶œ Â· âŠ¢twoá¶œ Â· âŠ¢sucá¶œ Â· âŠ¢zero

-- Interaction with Agda


-- Lookup is functional
âˆ‹-functional : âˆ€ {Î“ x A B} â†’ Î“ âˆ‹ x â¦‚ A â†’ Î“ âˆ‹ x â¦‚ B â†’ A â‰¡ B
âˆ‹-functional Z        Z          =  refl
âˆ‹-functional Z        (S xâ‰¢ _)   =  âŠ¥-elim (xâ‰¢ refl)
âˆ‹-functional (S xâ‰¢ _) Z          =  âŠ¥-elim (xâ‰¢ refl)
âˆ‹-functional (S _ âˆ‹x) (S _ âˆ‹xâ€²)  =  âˆ‹-functional âˆ‹x âˆ‹xâ€²

-- Non-examples
nopeâ‚ : âˆ€ {A} â†’ Â¬ (âˆ… âŠ¢ `zero Â· `suc `zero â¦‚ A)
nopeâ‚ (() Â· _)

nopeâ‚‚ : âˆ€ {A} â†’ Â¬ (âˆ… âŠ¢ Æ› "x" â‡’ ` "x" Â· ` "x" â¦‚ A)
nopeâ‚‚ (âŠ¢Æ› (âŠ¢` âˆ‹x Â· âŠ¢` âˆ‹xâ€²))  =  contradiction (âˆ‹-functional âˆ‹x âˆ‹xâ€²)
  where
  contradiction : âˆ€ {A B} â†’ Â¬ (A â‡’ B â‰¡ A)
  contradiction ()

-- Your code goes here

-- Your code goes here

-- Unicode
 {- 
This chapter uses the following unicode:

    â‡’  U+21D2  RIGHTWARDS DOUBLE ARROW (\=>)
    Æ›  U+019B  LATIN SMALL LETTER LAMBDA WITH STROKE (\Gl-)
    Â·  U+00B7  MIDDLE DOT (\cdot)
    â‰Ÿ  U+225F  QUESTIONED EQUAL TO (\?=)
    â€”  U+2014  EM DASH (\em)
    â†   U+21A0  RIGHTWARDS TWO HEADED ARROW (\rr-)
    Î¾  U+03BE  GREEK SMALL LETTER XI (\Gx or \xi)
    Î²  U+03B2  GREEK SMALL LETTER BETA (\Gb or \beta)
    Î“  U+0393  GREEK CAPITAL LETTER GAMMA (\GG or \Gamma)
    â‰   U+2260  NOT EQUAL TO (\=n or \ne)
    âˆ‹  U+220B  CONTAINS AS MEMBER (\ni)
    âˆ…  U+2205  EMPTY SET (\0)
    âŠ¢  U+22A2  RIGHT TACK (\vdash or \|-)
    â¦‚  U+2982  Z NOTATION TYPE COLON (\:)
    ðŸ˜‡  U+1F607  SMILING FACE WITH HALO
    ðŸ˜ˆ  U+1F608  SMILING FACE WITH HORNS

We compose reduction `â€”â†’` from an em dash `â€”` and an arrow `â†’`.
Similarly for reflexive and transitive closure `â€”â† `. -}
-}
